
<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - geometry - catmull spline editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>

<script src="js/three.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/controls/TransformControls.js"></script>
<script src="js/controls/DragControls.js"></script>
<script src="js/renderers/Projector.js"></script>
<script src="js/loaders/OBJMTLLoader.js"></script>
<script src="js/loaders/MTLLoader.js"></script>
<script src="js/geometries/TextGeometry.js"></script>
<script src="js/utils/FontUtils.js"></script>
<script src="js/fonts/helvetiker_bold.typeface.js"></script>
<script src="js/fonts/helvetiker_regular.typeface.js"></script>

<script src="js/libs/stats.min.js"></script>


<script>

    String.prototype.format = function () {

        var str = this;
        for ( var i = 0; i < arguments.length; i ++ ) {

            str = str.replace( '{' + i + '}', arguments[ i ] );

        }
        return str;

    };

    var container, stats;
    var camera, textCamera, scene, textScene, renderer;
    var splineHelperObjects = [],
            splineOutline;
    var splinePointsLength = 4;
    var positions = [];
    var options;

    var shadowPoint =[];
    var textGeo = [];
    var textGeometryMesh=[];

    var dynamicPoints = [];
    var dynamicPointMesh = [];

    var geometry = new THREE.BoxGeometry(5,5,5);

    var ARC_SEGMENTS = 200;
    var aircraft = new Aircraft();

    var initLatitude = 22.3363168;
    var initLongitude = 114.2659089;

    var scale = 18;  //default scaler
    var rateLongitudeRight = 0.011/Math.pow(2,scale-7);// (/512)->16;
    var rateLatitudeDown = -0.0102/Math.pow(2,scale-7);// (/512)->16;

    var mapPlane = [];
    var mapLocation = [];

    var lineMaterial = new THREE.LineBasicMaterial({
        color: 0xFF00ff
    });
    var material = new THREE.MeshBasicMaterial({color: 0xff0000});

    init();
    animate();

    function cameraInit() {
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 1000;
        scene.add(camera);
        textCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        textCamera.position.set(-700,800,480); // left/right, reserve, up/down
        textCamera.lookAt(new THREE.Vector3(-700,0,480));
        textCamera.rotation.z = 0;
        textScene.add(textCamera);
    }

    function lightInit() {
        scene.add( new THREE.AmbientLight( 0xf0f0f0 ) );
        textScene.add( new THREE.AmbientLight( 0xf0f0f0 ) );
    }

    function loadMap(latitude, longitude, x, z){
        for (var i = 0; i < mapLocation.length; i++){
            if((x == mapLocation[i].X) && (z == mapLocation[i].Z)){
               return;
            }
        }

        var texloader = new THREE.TextureLoader();
        texloader.setCrossOrigin('');
        var tex = texloader.load("https://maps.googleapis.com/maps/api/staticmap?center=" + latitude + "," + longitude + "&zoom="+ scale + "&size=512x512&key=AIzaSyCC9wt1CChcOEDAuTgH10Y75Fj5l1ai2dE");
        //var tex = texloader.load("https://api.mapbox.com/v4/mapbox.streets/"+longitude+","+latitude+",16/512x512.png128?access_token=pk.eyJ1IjoibGFueXVzZWEiLCJhIjoiY2lpNnJtYzdoMDF1ZnRybTA0bTZlMmNtciJ9.9fKQNjEiRCCkSCXpMBWK1w");

        //a plane in the ground
        var planeGeometry = new THREE.PlaneGeometry(512, 512);
        planeGeometry.rotateX(-Math.PI / 2);
        var planeMaterial = new THREE.MeshBasicMaterial({color: 0xeeeeee, map: tex});

        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.x = x;
        plane.position.z = z;
        plane.position.y = 0;

        plane.receiveShadow = true;
        scene.add(plane);
        mapPlane.push(plane);

        var mapCoordinate = {X: x, Z: z};
        mapLocation.push(mapCoordinate);
    }

    function updateRate() {
        rateLongitudeRight = 0.011/Math.pow(2,scale-7);// (/512)->16;
        rateLatitudeDown = -0.0102/Math.pow(2,scale-7);// (/512)->16;
    }


    function removeMap(){
        for (var i = 0; i < mapPlane.length; i++){
            scene.remove(mapPlane[i]);
        }
        mapPlane = [];
        mapLocation = [];
    }

    function updateMap(){
        var roll = camera.rotation.y;//
        var pitch = camera.rotation.x;//[-pi, 0]
        var yaw = camera.rotation.z;//[0,pi)(-pi,0]

        //unit is 512
        var newCenterX = ((camera.position.x - 1000*Math.sin(roll))/512).toFixed()*512;
        var newCenterZ = ((camera.position.z - 1000*Math.cos(pitch)*Math.cos(roll))/512).toFixed()*512;
        //camera mode is a completed mystery, I have to *Math.cos(roll) for movement on z-axis.

        //latitude/longitude for the center point
        updateRate();
        var newLatitude = initLatitude + newCenterZ*rateLatitudeDown;
        var newLongitude = initLongitude + newCenterX*rateLongitudeRight;

        for (var i = -1; i <= 1; i ++){
            for (var j = -1; j <= 1; j ++){
                loadMap(newLatitude-i*512*rateLatitudeDown,
                        newLongitude+j*512*rateLongitudeRight,
                        512*j  + newCenterX,
                        -512*i + newCenterZ
                        );
            }
        }
    }


    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        scene = new THREE.Scene();
        textScene = new THREE.Scene();

        //create camera
        cameraInit();

        //create light
        lightInit();

        //loadMap(22.3363168,114.2549089,-512,0); //512 -> 0.011, longitude increase, move right
        //loadMap(22.3363168,114.2659089,0,0);
        //loadMap(22.3261668,114.2659089,0,512); //512->-0.0102, latitude increase, move negative up

        updateRate();

        for (var i = -1; i <= 1; i ++){
            for (var j = -1; j <= 1; j ++){
                loadMap(initLatitude-i*512*rateLatitudeDown, initLongitude+j*512*rateLongitudeRight, 512*j,-512*i);
            }
        }

        //the axis
        var axis = new THREE.AxisHelper();
        axis.position.set( -500, -500, -500 );
        scene.add( axis );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setClearColor( 0xf0f0f0 );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;
        renderer.autoClear = false;
        container.appendChild( renderer.domElement );

        //for the info on top middle
        var info = document.createElement( 'div' );
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.innerHTML = 'DJI GroundStation';
        options = document.createElement( 'div' );
        options.style.position = 'absolute';
        options.style.top = '30px';
        options.style.width = '100%';
        options.style.textAlign = 'center';

        options.innerHTML = 'Waypoints: <input type="button" onclick="addPoint();" value="+" />\
<input type="button" onclick="removePoint();" value="-" />';

        container.appendChild( info );
        container.appendChild( options );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        // Controls
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.damping = 0.2;
        controls.addEventListener( 'change', render );

        transformControl = new THREE.TransformControls( camera, renderer.domElement );
        transformControl.addEventListener( 'change', render );

        scene.add( transformControl );

        // Hiding transform situation is a little in a mess :()
        transformControl.addEventListener( 'change', function( e ) {
            cancelHideTransorm();

        } );

        transformControl.addEventListener( 'mouseDown', function( e ) {

            cancelHideTransorm();

        } );

        transformControl.addEventListener( 'mouseUp', function( e ) {
            delayHideTransform();

        } );

        transformControl.addEventListener( 'objectChange', function( e ) {

            console.log(e);//open the menu
            updatePath(positions);
            updateText();
            updateShadow();

        } );

        var dragcontrols = new THREE.DragControls( camera, splineHelperObjects, renderer.domElement ); //

        dragcontrols.on( 'hoveron', function( e ) {

            transformControl.attach( e.object );
            cancelHideTransorm();

        } );

        dragcontrols.on( 'hoveroff', function( e ) {

            if ( e ) delayHideTransform();

        } );


        controls.addEventListener( 'start', function() {

            cancelHideTransorm();

        } );

        controls.addEventListener( 'end', function() {

            delayHideTransform();
            updateMap();
        } );


        controls.domElement.addEventListener('mousewheel', function(event){
            if(event.ctrlKey){
                controls.minDistance = controls.constraint.radius_.toFixed();
                controls.maxDistance = controls.constraint.radius_.toFixed();
                if(controls.scrollData > 0){
                    scale ++;
                    controls.target.x *=2;
                    controls.target.z *=2;
                    camera.position.x *=2;
                    camera.position.z *=2;

                    for (var i = 0; i < positions.length; i++){
                        positions[i].x*=2;
                        positions[i].z*=2;
                    }
                }
                else if(controls.scrollData < 0){
                    scale --;
                    controls.target.x /=2;
                    controls.target.z /=2;
                    camera.position.x /=2;
                    camera.position.z /=2;

                    for (var i = 0; i < positions.length; i++){
                        positions[i].x/=2;
                        positions[i].z/=2;
                    }
                }
                else{

                }
                removeMap();
                updateMap();
                updateShadow();
                updateText();
                updatePath(positions);
            }
            else{
                controls.minDistance = 400;
                controls.maxDistance = 2000;
            }

        } );
        var hiding;

        function delayHideTransform() {

            cancelHideTransorm();
            hideTransform();

        }

        function hideTransform() {

            hiding = setTimeout( function() {

                transformControl.detach( transformControl.object );

            }, 2500 )

        }

        function cancelHideTransorm() {

            if ( hiding ) clearTimeout( hiding );

        }

        var text = "Index, Latitude, Longitude, Altitude";
        var textGeometry = new THREE.TextGeometry(text,{
                size:15,
                height:0,
                font:"helvetiker",
                curveSegments:1,
                weight:"normal",
                style:"normal"
            });
        var textGeometryMesh = new THREE.Mesh(textGeometry,material);
        textGeometryMesh.position.set(0,0,-30);
        textGeometryMesh.rotateX(-Math.PI / 2);
        textScene.add(textGeometryMesh);

        load( [ new THREE.Vector3(0,0,0),
            new THREE.Vector3( 289.76843686945404, 452.51481137238443, 56.10018915737797 ),
            new THREE.Vector3( -53.56300074753207, 171.49711742836848, -14.495472686253045 ),
            new THREE.Vector3( -91.40118730204415, 176.4306956436485, -6.958271935582161 ),
            new THREE.Vector3( -383.785318791128, 491.1365363371675, 47.869296953772746 ) ] );

        loadM100();
        createSky();
    }

    function updatePath(position) {
        //clear
        clearFlyPath();

        //draw
        for (var i = 0; i < position.length; i++){
            drawDynamicPath(position[i]);
        }
    }

    function clearFlyPath() {
        if (dynamicPointMesh == null) return;
        for (var i = 0; i < dynamicPointMesh.length; i++) {
            scene.remove(dynamicPointMesh[i]);
            dynamicPoints[i] = null;
            dynamicPointMesh[i].material.dispose();
            dynamicPointMesh[i].geometry.dispose();
        }
        dynamicPointMesh = [];
        dynamicPoints = [];
    }

    function drawDynamicPath(p) {
        if (dynamicPoints == null || dynamicPointMesh == null)
            return;
        if (dynamicPoints.length > 0) {
            // check if new position is near to last point, if is, return
            var last_p = dynamicPoints[dynamicPoints.length - 1];
            var v_diff = new THREE.Vector3();
            v_diff.subVectors(p, last_p);
            if (v_diff.length() < 0.1)
                return;

            var g = new THREE.Geometry();
            g.vertices.push(dynamicPoints[dynamicPoints.length - 1]);
            g.vertices.push(p);
            var m = new THREE.Line(g, lineMaterial);
            scene.add(m);
            dynamicPointMesh.push(m);
        }
        dynamicPoints.push(p);

        if (dynamicPointMesh.length > 2000) {
            scene.remove(dynamicPointMesh.shift());
        }
        if (dynamicPoints.length > 3000) {
            dynamicPoints.shift();
        }
    }

    function Aircraft() {
        this.object = null;
        this.scale = 1;
        this.transform_base = new THREE.Matrix4();
        this.transform = new THREE.Matrix4();
        this.rotationM = new THREE.Matrix4();
        this.position = new THREE.Vector3();
        this.Reset = function () {
            this.transform.copy(this.transform_base);
        };

        var scope = this;

        this.Update = function () {
            if (scope.object == null)
                return;
            scope.object.scale.set(scope.scale, scope.scale, scope.scale);
            scope.rotationM.extractRotation(scope.transform);
            scope.object.rotation.setFromRotationMatrix(scope.rotationM);
            scope.object.position.setFromMatrixPosition(scope.transform);
        };
        this.SetCurrentAsInitial = function () {
            this.transform_base.copy(this.transform);
        };
        this.SetScale = function (s) {
            this.scale = s;
            this.Update();
        };
        this.SetATTI = function (q) {
            var m = new THREE.Matrix4();
            m.makeRotationFromQuaternion(q);
            m.multiply(this.transform);
            this.transform.copy(m);
            this.Update();
        };
        this.SetPosition = function (p) {
            this.position.copy(p);
            this.transform.setPosition(p);
            this.Update();
        };

        this.Unload = function(){
            if (this.object != null) {
                scene.remove(this.object);
                this.object = null;
            }
        };
    }
    function loadM100() {
        var loader = new THREE.OBJMTLLoader();
        loader.load( 'data/m100_body.obj', 'data/m100_body.mtl', function ( object ) {
            aircraft.Unload();
            aircraft.object = object;
            aircraft.transform.makeRotationX(-Math.PI / 2);
            var r = new THREE.Matrix4();
            r.makeRotationZ(-Math.PI / 2);
            aircraft.transform.multiply(r);
            aircraft.SetScale(100); //needs to modify
            aircraft.SetCurrentAsInitial();
            aircraft.Update();
            scene.add( object );
        });
    }
    function createSky() {
        var path = "data/";
        var format = '.jpg';
        var urls = [
            path + 'px' + format, path + 'nx' + format,
            path + 'py' + format, path + 'ny' + format,
            path + 'pz' + format, path + 'nz' + format
        ];

        var textureCube = THREE.ImageUtils.loadTextureCube(urls);

        var shader = THREE.ShaderLib["cube"];
        shader.uniforms["tCube"].value = textureCube;

        // We're inside the box, so make sure to render the backsides
        // It will typically be rendered first in the scene and without depth so anything else will be drawn in front
        var material = new THREE.ShaderMaterial({
            fragmentShader : shader.fragmentShader,
            vertexShader   : shader.vertexShader,
            uniforms       : shader.uniforms,
            depthWrite     : false,
            side           : THREE.BackSide
        });

        // The box dimension size doesn't matter that much when the camera is in the center.  Experiment with the values.
        var skyMesh = new THREE.Mesh( new THREE.CubeGeometry( 10000, 10000, 10000, 1, 1, 1 ), material );
        skyMesh.renderDepth = -10;


        scene.add(skyMesh);
    }


    function addSplineObject( position ) {

        var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {
            color: Math.random() * 0xffffff
        } ) );
        object.material.ambient = object.material.color;
        if ( position ) {

            object.position.copy( position );

        } else {

            object.position.x = Math.random() * 1000 - 500;
            object.position.y = Math.random() * 600;
            object.position.z = Math.random() * 800 - 400;

        }

        object.castShadow = true;
        object.receiveShadow = true;
        object.my_mash = true;
        scene.add( object );
        splineHelperObjects.push( object );
        return object;

    }

    function updateShadow(){
        for (var i = 0; i < positions.length;i++){
            shadowPoint[i].position.set(positions[i].x,0,positions[i].z);
        }
    }


    function updateText(){
        updateRate();
        for (var i = 0; i < positions.length;i++) {
            var text = ""+i+": (" + ((initLatitude+positions[i].z.toFixed()*rateLatitudeDown*180/Math.PI)).toFixed(6) + //latitude
                        ",  " +  ((initLongitude+positions[i].x.toFixed()*rateLongitudeRight*180/Math.PI)).toFixed(6) + //longitude
                        ",  " + positions[i].y.toFixed() + //altitude
                        ")";
            textGeo[i].dispose();
            textGeo[i] = new THREE.TextGeometry(text,{
                size:15,
                height:0,
                font:"helvetiker",
                curveSegments:1,
                weight:"normal",
                style:"normal"
            });
            textScene.remove(textGeometryMesh[i]);
            textGeometryMesh[i].material.dispose();
            textGeometryMesh[i].geometry.dispose();
            textGeometryMesh[i] = new THREE.Mesh(textGeo[i],material);
            textGeometryMesh[i].position.set( 0, 0, 30 * i);
            textGeometryMesh[i].rotateX(-Math.PI / 2);
            textScene.add(textGeometryMesh[i]);

        }
    }

    function addPoint() {
        //push point into positions
        splinePointsLength ++;
        var point = addSplineObject();
        positions.push( point.position );

        //push its new shadow
        var geometry = new THREE.TorusGeometry(2,1.2,5,36);
        var torus = new THREE.Mesh(geometry, material);
        torus.rotateX (- Math.PI / 2);
        shadowPoint.push(torus);
        scene.add(shadowPoint[shadowPoint.length-1]);

        //push its text
        var text = "";//update later
        textGeo.push(new THREE.TextGeometry(text,{
            size:5,
            height:1,
            font:"helvetiker",
            curveSegments:5,
            weight:"normal",
            stype:"normal"
        }));
        textGeometryMesh.push(new THREE.Mesh(textGeo[textGeo.length-1],material));
        scene.add(textGeometryMesh[textGeometryMesh.length-1]);

        //update the path
        updatePath(positions);
        updateShadow();
        updateText();
    }

    function removePoint() {

        if ( splinePointsLength <= 4 ) {

            return;

        }
        splinePointsLength --;
        positions.pop();
        scene.remove(shadowPoint.pop());
        scene.remove(splineHelperObjects.pop() );
        scene.remove(textGeometryMesh.pop());
        textGeo.pop();

        updatePath(positions);
        updateShadow();
        updateText();
    }


    function load( new_positions ) {

        while ( new_positions.length > positions.length ) {

            addPoint();

        }

        while ( new_positions.length < positions.length ) {

            removePoint();

        }

        for ( i = 0; i < positions.length; i ++ ) {

            positions[ i ].copy( new_positions[ i ] );

        }
        updateShadow();
        updateText();
        updatePath(positions);
    }

    function animate() {

        requestAnimationFrame( animate );
        stats.update();
        controls.update();
        transformControl.update();
        render();

    }

    function render() {

        renderer.clear();
        renderer.render( scene, camera );
        renderer.clearDepth();
        renderer.render(textScene,textCamera);

    }

</script>

</body>
</html>
